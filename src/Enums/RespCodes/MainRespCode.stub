<?php

namespace App\Enums\RespCodes;

use Aslnbxrz\SimpleException\Contracts\ThrowableEnum;
use Illuminate\Support\Str;
use Symfony\Component\HttpFoundation\Response;

enum MainRespCode: int implements ThrowableEnum
{
    case AppVersionOutdated = 426;
    case AppMissingHeaders = 1000;
    case AppWrongLanguage = 1001;
    case ValidationError = 1002;
    case AppInvalidDeviceModel = 1003;
    case MaintenanceMode = 503;
    case ServiceUnavailable = 504;
    case InternalServerError = 500;
    case BadGateway = 502;
    case GatewayTimeout = 505;
    case Unauthorized = 401;
    case Forbidden = 403;
    case NotFound = 404;
    case TooManyRequests = 429;
    case RateLimitExceeded = 430;

    public function message(): string
    {
        // Try to get translated message if Laravel is available
        if (function_exists('__')) {
            try {
                $translationKey = 'main.' . $this->getTranslationKey();
                $translated = __($translationKey);
                
                // If translation exists and is different from key, return it
                if ($translated !== $translationKey) {
                    return $translated;
                }
            } catch (\Exception $e) {
                // If translation fails, fall back to default messages
            }
        }

        // Fallback to default messages
        return match ($this) {
            self::AppVersionOutdated => 'Application version is outdated. Please update to the latest version.',
            self::AppMissingHeaders => 'Required headers are missing from the request.',
            self::AppWrongLanguage => 'Invalid or unsupported language specified.',
            self::ValidationError => 'The given data was invalid.',
            self::AppInvalidDeviceModel => 'Invalid or unsupported device model.',
            self::MaintenanceMode => 'The application is currently in maintenance mode.',
            self::ServiceUnavailable => 'Service is temporarily unavailable. Please try again later.',
            self::InternalServerError => 'An internal server error occurred. Please try again later.',
            self::BadGateway => 'Bad gateway. Please try again later.',
            self::GatewayTimeout => 'Gateway timeout. Please try again later.',
            self::Unauthorized => 'You are not authorized to perform this action.',
            self::Forbidden => 'Access to this resource is forbidden.',
            self::NotFound => 'The requested resource was not found.',
            self::TooManyRequests => 'Too many requests. Please slow down.',
            self::RateLimitExceeded => 'Rate limit exceeded. Please try again later.',
        };
    }

    private function getTranslationKey(): string
    {
        return $this->camelToSnake($this->name);
    }

    private function camelToSnake(string $string): string
    {
        return strtolower(preg_replace('/([a-z])([A-Z])/', '$1_$2', $string));
    }

    public function statusCode(): int
    {
        return $this->value;
    }

    public function httpStatusCode(): int
    {
        return match ($this) {
            self::AppVersionOutdated => Response::HTTP_UPGRADE_REQUIRED,
            self::AppMissingHeaders => Response::HTTP_BAD_REQUEST,
            self::AppWrongLanguage => Response::HTTP_NOT_ACCEPTABLE,
            self::ValidationError => Response::HTTP_UNPROCESSABLE_ENTITY,
            self::AppInvalidDeviceModel => Response::HTTP_INTERNAL_SERVER_ERROR,
            self::MaintenanceMode => Response::HTTP_SERVICE_UNAVAILABLE,
            self::ServiceUnavailable => Response::HTTP_SERVICE_UNAVAILABLE,
            self::InternalServerError => Response::HTTP_INTERNAL_SERVER_ERROR,
            self::BadGateway => Response::HTTP_BAD_GATEWAY,
            self::GatewayTimeout => Response::HTTP_GATEWAY_TIMEOUT,
            self::Unauthorized => Response::HTTP_UNAUTHORIZED,
            self::Forbidden => Response::HTTP_FORBIDDEN,
            self::NotFound => Response::HTTP_NOT_FOUND,
            self::TooManyRequests => Response::HTTP_TOO_MANY_REQUESTS,
            self::RateLimitExceeded => Response::HTTP_TOO_MANY_REQUESTS,
        };
    }
}
